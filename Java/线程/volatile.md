## 简介
synchronized关键字可以线程安全的帮助我们操作共享变量，但是会影响程序的执行效率且开销比较大，而volatile关键字在一定程序上为同步访问提供了免锁的机制，是同步操作的一种补充；

## Java内存模型
Java内存模型定义了线程的工作内存和主存之间的抽象关系：线程之间的共享变量存储在主存中，每个线程都有一个私有的工作内存，工作内存中存储了主存中共享变量的副本。

例如，线程A与线程B之间若要通过共享变量通信的话，必须要经历下面两个步骤：
1. 线程A把线程A工作内存中更新过的共享变量刷新到主存中去。
2. 线程B到主存中去读取线程A之前已更新过的共享变量。

由此可见，如果我们执行下面的语句：`int i=3;`,执行线程必须先在自己的工内存中对变量i所在的缓存行进行赋值操作，然后再写入主存当中，而不是直接将数值3写入主存当中。

## 并发安全的三原则
要保证并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。

1、原子性

原子性是指多个操作要么一起执行，要么都不执行；在Java中对基本数据类型变量的读取和赋值操作是原子性操作。如下所示：
```
x = 3; //语句1
y = x; //语句2
x++; //语句3
```
在上面3个语句中，只有语句1是原子性操作，其他两个语句都不是原子性操作。语句2虽说很短，但它包含了两个操作，它先读取x的值，再将x的值写入工作内存。读取x的值以及将x的值写入工作内存这两个操作单拿出来都是原子性操作，但是合起来就不是原子性操作了。语句3包括3个操作：读取x的值、对x的值进行加1、向工作内存写入新值。通过这3个语句我们得知，一个语句含有多个操作时，就不是原子性操作，只有简单地读取和赋值（将数字赋值给某个变量）才是原子性操作。


2、可见性

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。当一个共享变量被volatile修饰时，它会保证修改的值立即被更新到主存，所以对其他线程是可见的。当有其他线程需要读取该值时，其他线程会去主存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，并不会立即被写入主存，何时被写入主存也是不确定的。当其他线程去读取该值时，此时主存中可能还是原来的旧值，这样就无法保证可见性。

3、有序性

有序性是指程序执行的顺序按照代码逻辑的先后顺序执行。在Java中处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的，这就是指令重排序。

在单线程的环境中，指令重排序对执行结果不会有影响，但是在多线程环境下，结果就不一样了，例如下面的程序：
```
//线程1:
context = loadContext();   //语句1
inited = true;             //语句2
 
//线程2:
while(!inited ){
  sleep()
}
doSomethingwithconfig(context);
```
上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。


## volatile的作用
当一个共享变量被volatile修饰之后，就具备了两个含义：
- 一个是线程修改了变量的值时，变量的新值对其他线程是立即可见的
- 另一个含义是禁止使用指令重排序。也就是在进行指令优化时，在volatile变量之前的语句不能在volatile变量后面执行；同样，在volatile变量之后的语句也不能在volatile变量前面执行。

synchronized关键字可防止多个线程同时执行一段代码(以此来保证操作执行的原子性)，但是会很影响程序执行效率。而volatile关键字在某些情况下的性能要优于synchronized。但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下两个条件：
- 运算结果并不依赖变量的当前值
- 变量不需要与其他的状态变量共同参与不变约束

## volatile的使用

1. 为什么双重检查模式中的使用volatile关键字？

<https://www.cnblogs.com/goodAndyxublog/p/11356402.html>


