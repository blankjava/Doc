方法是类或对象的行为特征的抽象，方法是类或对象最重要的组成部分。但从功能上来看，方法完全类似千传统结构化程序设计里的函数。值得指出的是，Java里的方法不能独立存在，所有的方法都必须定义在类里。方法在逻辑上要么属于类， 要么属千对象。

## 方法的所属性
不论是从定义方法的语法来看，还是从方法的功能来看，都不难发现方法和函数之间的相似性。实际上， 方法确实是由传统的函数发展而来的， 方法与传统的函数有着显著不同： 在结构化编程语言里，函数是一等公民，整个软件由一个个的函数组成；在面向对象编程语言里，类才是一等公民，整个系统由一个个的类组成。因此在Java语言里， 方法不能独立存在， 方法必须属于类或对象。

因此，如果需要定义方法，则只能在类体内定义，不能独立定义一个方法。一旦将一个方法定义在某个类的类体内，如果这个方法使用了static修饰， 则这个方法属于这个类，否则这个方法属于这个类的实例。

Java语言是静态的。一个类定义完成后，只要不再重新编译这个类文件，该类和该类的对象所拥有的方法是固定的， 永远都不会改变。

因为Java里的方法不能独立存在， 它必须属于一个类或一个对象， 因此方法也不能像函数那样被独立执行，执行方法时必须使用类或对象来作为调用者，即所有方法都必须使用“ 类.方法” 或“ 对象.方法” 的形式来调用。这里可能产生一个问题：同一个类里不同方法之间相互调用时，不就可以直接调用吗？这里需要指出：同一个类的一个方法调用另外一个方法时，如果被调方法是普通方法，则默认使用this作为调用者；如果被调方法是静态方法，则默认使用类作为调用者。也就是说，表面上看起来某些方法可以被独立执行， 但实际上还是使用this或者类来作为调用者。

永远不要把方法当成独立存在的实体，正如现实世界由类和对象组成，而方法只能作为类和对象的附属，Java语言里的方法也是一样。Java语言里方法的所属性主要体现在如下几个方面。
- 方法不能独立定义， 方法只能在类体里定义。
- 从逻辑意义上来看， 方法要么属于该类本身， 要么属于该类的一个对象。
- 永远不能独立执行方法， 执行方法必须使用类或对象作为调用者。

使用static修饰的方法属于这个类本身，使用static修饰的方法既可以使用类作为调用者来调用，也可以使用对象作为调用者来调用。但值得指出的是， 因为使用static修饰的方法还是属于这个类的，因此使用该类的任何对象来调用这个方法时将会得到相同的执行结果，这是由于底层依然是使用这些实例所属的类作为调用者。

没有static修饰的方法则属于该类的对象，不属于这个类本身。因此没有static修饰的方法只能使用对象作为调用者来调用，不能使用类作为调用者来调用。使用不同对象作为调用者来调用同一个普通方法，可能得到不同的结果。


## 参数传递机制
前面已经介绍了Java里的方法是不能独立存在的， 调用方法也必须使用类或对象作为主调者。如果声明方法时包含了形参声明， 则调用方法时必须给这些形参指定参数值， 调用方法时实际传给形参的参数值也被称为实参。

那么， Java的实参值是如何传入方法的呢？这是由Java方法的参数传递机制来控制的，Java里方法的参数传递方式只有一种：值传递。所谓值传递，就是将实际参数值的副本（复制品）传入方法内，**而参数本身不会受到任何影响**；

下面程序演示了基本类型参数传递的效果。
```
private static void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    System.out.println("swap方法中，a = " + a + ",b = " + b);
}

public static void main(String[] args) {
    int a = 6;
    int b = 9;
    swap(a, b);
    System.out.println("main方法中，a = " + a + ",b = " + b);
}
```
上面的程序输出的结果为：
```
swap方法中，a = 9,b = 6
main方法中，a = 6,b = 9
```
从上面运行结果来看，swap()方法里a和b的值是9、6, 交换结束后， 变量a和b的值依然是6、9。从这个运行结果可以看出， main()方法里的变量a和b, 并不是swap()方法里的a和b。正如前面讲的，swap()方法的a和b 只是mai顶）方法里变量a和b 的复制品。下面通过示意图来说明上面程序的执行过程。
```
    |       |           |       |           |       |
    |       |           |       |           |       |
    |       |           |       |           |-------|
    |       |           |       |      temp |   6   |
    |-------|           |-------|           |-------|
  b |   9   |-------> b |   9   |         b |   6   |
    |-------|           |-------|           |-------|
  a |   6   |-------> a |   6   |         a |   9   |
    |-------|           |-------|           |-------|
     main栈区            swap栈区          交换后swap栈区
```
在main()方法中调用swap()方法时， main()方法还未结束。因此， 系统分别为main()方法和swap()方法分配两块栈区， 用于保存main()方法和swap()方法的局部变量。main()方法中的a、b变量作为参数值传入swap()方法，实际上是在swap()方法栈区中重新产生了两个变量a、b, 并将main()方法栈区中a、b变量的值分别赋给swap()方法栈区中的a、b 参数（就是对swap()方法的a、b 形参进行了初始化）。此时， 系统存在两个a变量、两个b变量， 只是存在于不同的方法栈区中而已。

程序在swap()方法中交换a、b两个变量的值，实际上是将形参a赋值给temp，再将形参b赋值给形参a，最后将temp赋值给形参b；

对于引用类型的参数传递， 一样采用的是值传递方式。但某些现象可能对引用类型的参数传递会产生一些误会。下面程序示范了引用类型的参数传递的效果。
```
public class Hello {
    public static class DataWrap {
        int a;
        int b;
    }

    private static void swap(DataWrap dataWrap) {
        int temp = dataWrap.a;
        dataWrap.a = dataWrap.b;
        dataWrap.b = temp;
        System.out.println("swap方法中，a = " + dataWrap.a + ",b = " + dataWrap.b);
    }

    public static void main(String[] args) {
        DataWrap dataWrap = new DataWrap();
        dataWrap.a = 6;
        dataWrap.b = 9;
        swap(dataWrap);
        System.out.println("main方法中，a = " + dataWrap.a + ",b = " + dataWrap.b);
    }
}
```
上面的程序运行后结果如下：
```
swap方法中，a = 9,b = 6
main方法中，a = 9,b = 6
```
从上面运行结果来看，在swap()方法里，a、b两个成员变量的值被交换成功。不仅如此， 当swap()方法执行结束后，main()方法里a、b两个成员变量的值也被交换了。这很容易造成一种错觉：调用swap()方法时，传入swap()方法的就是dw 对象本身， 而不是它的复制品。但这只是一种错觉， 下面还是结合示意图来说明程序的执行过程。
```
        |       |           |       |
        |       |           |       | 
        |       |           |       | 
        |-------|  dataWrap |-------|
dataWrap| 10000 |---------->| 10000 |
        |-------|           |-------|
         main栈区            wrap栈区       

       DataWrap对象
        |-------|           |-------|
   10000|   6   | a    10000|   9   | a
        |-------|           |-------|
   10001|   9   | b    10001|   6   | b
        |-------|           |-------|
        |       |           |       |
       堆内存交换前         堆内存交换后
```
这种参数传递方式是不折不扣的值传递方式，系统一样复制了dataWrap的副本传入swap()方法， 但关键在于dataWrap只是一个引用变量，所以系统复制了dataWrap变量，但并未复制DataWrap对象。

## 可变形参
从JDK1.5之后，Java允许定义形参个数可变的参数， 从而允许为方法指定数量不确定的形参。如果在定义方法时， 在最后一个形参的类型后增加三点（...）， 则表明该形参可以接受多个参数值， 多个参数值被当成数组传入。也就是说，下面两个方法签名的效果完全一样。
```
public static void test(int a,String... books)
public static void test(int a,String[] ks)
```
这两种形式都包含了一个名为books的形参，在两个方法的方法体内都可以把books 当成数组处理。但区别是调用两个方法时存在差别，对于以可变形参的形式定义的方法，调用方法时更加简洁，如下面代码所示。
```
test(1,"aaa","bbbb","ccc");
test(2,new String[]{"aaa","bbbb","ccc"});
```
对比两种调用test()方法的代码，明显第一种形式更加简洁。实际上，即使是采用形参个数可变的形式来定义方法，调用该方法时也一样可以为个数可变的形参传入一个数组。

最后还要指出的是，数组形式的形参可以处于形参列表的任意位置，但个数可变的形参只能处于形参列表的最后。也就是说，一个方法中最多只能有一个个数可变的形参。

## 递归方法

## 方法重载