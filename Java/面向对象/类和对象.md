## 定义类
面向对象的程序设计过程中有两个重要概念：类(class) 和对象(object, 也被称为实例，instance),其中类是某一批对象的抽象，可以把类理解成某种概念；对象才是一个具体存在的实体；

Java 语言是面向对象的程序设计语言， 类和对象是面向对象的核心。Java 语言提供了对创建类和创建对象简单的语法支持。

Java 语言里定义类的简单语法如下：
```
[修饰符] class 类名{
    零个或多个变量；
    零个或多个构造器；
    零个或多个方法；
} 
```
在上面的语法格式中，修饰符可以是public、final、abstract, 或者完全省略这三个修饰符， 类名只要是一个合法的标识符即可，但这仅仅满足的是Java 的语法要求；如果从程序的可读性方面来看，Java类名必须是由一个或多个有意义的单词连缀而成的，每个单词首字母大写，共他字母全部小写， 单词与单词之间不要使用任何分隔符。

对一个类定义而言， 可以包含三种最常见的成员：构造器、成员变量和方法，三种成员都可以定义零个或多个， 如果三种成员都只定义零个， 就是定义了一个空类， 这没有太大的实际意义。

类里各成员之间的定义顺序没有任何影响， 各成员之间可以相互调用， 但需要指出的是，static修饰的成员不能访问没有static修饰的成员。

成员变量用于定义该类或该类的实例所包含的状态数据，方法则用千定义该类或该类的实例的行为特征或者功能实现。构造器用于构造该类的实例，Java语言通过new关键字来调用构造器， 从而返回该类的实例。

构造器是一个类创建对象的根本途径，如果一个类没有构造器， 这个类通常无法创建实例。因此，Java语言提供了一个功能：如果程序员没有为一个类编写构造器，则系统会为该类提供一个默认的构造器。一旦程序员为一个类提供了构造器，系统将不再为该类提供构造器。

定义成员变量的语法格式如下：
```
[修饰符] 类型 成员变量名 [= 默认值]
```
对定义成员变量语法格式的详细说明如下。  
- 修饰符： 修饰符可以省略，也可以是public、protected、private、static、final, 其中public、protected、private 三个最多只能出现其中之一，可以与static、final 组合起来修饰成员变量。
- 类型：类型可以是Java 语言允许的任何数据类型， 包括基本类型和现在介绍的引用类型。
- 成员变量名：成员变量名只要是一个合法的标识符即可，但这只是从语法角度来说的；如果从程序可读性角度来看，成员变量名应该由一个或多个有意义的单词连缀而成，第一个单词首字母小写，后面每个单词首字母大写，其他字母全部小写，单词与单词之间不要使用任何分隔符。成员变量用于描述类或对象包含的状态数据，因此成员变量名建议使用英文名词。
- 默认值：定义成员变量还可以指定一个可选的默认值。

定义方法的语法格式如下：
```
[修饰符] 方法返回值类型 方法名(参数列表){
    语句；
}
```
对定义方法语法格式的详细说明如下。  
- 修饰符：修饰符可以省略，也可以是public、protected、private、static、final、abstract, 其中public、protected、private 三个最多只能出现其中之一；final 和abstract 最多只能出现其中之一，它们可以与static 组合起来修饰方法。
- 方法返回值类型：返回值类型可以是Java 语言允许的任何数据类型，包括基本类型和引用类型；如果声明了方法返回值类型，则方法体内必须有一个有效的return 语句， 该语句返回一个变量或一个表达式， 这个变量或者表达式的类型必须与此处声明的类型匹配。除此之外，如果一个方法没有返回值，则必须使用void来声明没有返回值。
- 方法名：方法名的命名规则与成员变量的命名规则基本相同，但由于方法用于描述该类或该类的实例的行为特征或功能实现，因此通常建议方法名以英文动词开头。
- 形参列表：形参列表用于定义该方法可以接受的参数，形参列表由零组到多组“ 参数类型形参名” 组合而成，多组参数之间以英文逗号(,)隔开，形参类型和形参名之间以英文空格隔开。一旦在定义方法时指定了形参列表，则调用该方法时必须传入对应的参数值——谁调用方法，谁负责为形参赋值。

方法体里多条可执行性语句之间有严格的执行顺序，排在方法体前面的语句总是先执行，排在方法体后面的语句总是后执行。

static 是一个特殊的关键字，它可用于修饰方法、成员变量等成员。static 修饰的成员表明它属于这个类本身， 而不属于该类的单个实例，因为通常把static 修饰的成员变量和方法也称为类变量、类方法。不使用static 修饰的普通方法成员变量则属于该类的单个实例，而不属于该类。因为通常把不使用static修饰的成员变量和方法也称为实例变量、实例方法。

由千static 的英文直译就是静态的意思，因此有时也把static 修饰的成员变量和方法称为静态变量和静态方法，把不使用static 修饰的成员变量和方法称为非静态变量和非静态方法。静态成员不能直接访问非静态成员。

构造器是一个特殊的方法，定义构造器的语法格式与定义方法的语法格式很像，定义构造器的语法格式如下：
```
[修饰符] 构造器名(形参列表){
    语句；
}
```
对定义构造器语法格式的详细说明如下。
- 修饰符： 修饰符可以省略， 也可以是public、protected、private其中之一。
- 构造器名： 构造器名必须和类名相同。
- 形参列表： 和定义方法形参列表的格式完全相同。

值得指出的是， 构造器既不能定义返回值类型， 也不能使用void 声明构造器没有返回值。如果为构造器定义了返回值类型， 或使用void声明构造器没有返回值，编译时不会出错， 但Java会把这个所谓的构造器当成方法来处理一—它就不再是构造器。


## 对象的生产和使用
创建对象的根本途径是构造器， 通过new关键字来调用某个类的构造器即可创建这个类的实例。
```
Person p = new Person;
```
创建对象之后， 接下来即可使用该对象了，Java的对象大致有如下作用。
- 访问对象的实例变量。
- 调用对象的方法。

如果访问权限允许，类里定义的方法和成员变量都可以通过类或实例来调用。

static修饰的方法和成员变量，既可通过类来调用， 也可通过实例来调用；没有使用static修饰的普通方法和成员变量， 只可通过实例来调用。

## 引用和指针
在上面的程序中创建了一个Person对象：
```
Person p = new Person;
```
在这行代码中实际产生了两个东西： 一个是p 变量，一个是Person对象。如果Person对象有两个实例变量name和age，那么在创建Person对
象时， 必然需要有对应的内存来存储Person对象的实例变量，如下所示：
```
堆内存
         ------------
  10000  | zhangsan | name
         ------------
  10001  | 18       | age
         ------------
  10002  |          |
         ------------
              .
              .
              .
```
Person对象由多块内存单元组成，不同内存块分别存储了Person对象的不同成员变量。当把这个Person对象赋值给一个引用变量时，实际是把Person对象的第一块内存单元的地址赋值给变量p，也就是说变量p里存放的仅仅是一个引用，它指向实际的对象。
```
栈内存
|       |
|       |
|       |
|       |
|       |
| 10000 | p
---------
```
栈内存里的引用变量并未真正存储对象的成员变量，对象的成员变量数据实际存放在堆内存里；而引用变量只是指向该堆内存里的对象。从这个角度来看， 引用变量与C语言里的指针很像，它们都是存储一个地址值，通过这个地址来引用到实际对象。实际上，Java里的引用就是C里的指针，只是Java语言把这个指针封装起来，避免开发者进行烦琐的指针操作。

当一个对象被创建成功以后，这个对象将保存在堆内存中，Java程序不允许直接访问堆内存中的对象，只能通过该对象的引用操作该对象。也就是说，不管是数组还是对象，都只能通过引用来访问它们。

堆内存里的对象可以有多个引用，即多个引用变量指向同一个对象，代码如下：
```
Person p2 = p;
```
上面代码把p变量的值赋值给p2变量，也就是将p变量保存的地址值赋给p2变量，这样p2变量和p变量将指向堆内存里的同一个Person对象。不管访问p2变量的成员变量和方法，还是访问p变量的成员变量和方法， 它们实际上是访问同一个Person对象的成员变量和方法;

如果堆内存里的对象没有任何变量指向该对象，那么程序将无法再访问该对象，这个对象也就变成了垃圾，Java的垃圾回收机制将回收该对象，释放该对象所占的内存区。因此，如果希望通知垃圾回收机制回收某个对象，只需切断该对象的所有引用变量和它之间的关系即可，也就是把这些引用变量赋值为null。

## this关键字
Java提供了一个this关键字，this关键字总是指向调用该方法的对象。根据this出现位置的不同，this作为对象的默认引用有两种情形。
- 构造器中引用该构造器正在初始化的对象。
- 在方法中引用调用该方法的对象。

this可以代表任何对象，当this出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，它所代表的只能是当前类的实例；只有当这个方法被调用时，它所代表的对象才被确定下来，谁在调用这个方法，this就代表谁。
