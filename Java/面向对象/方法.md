方法是类或对象的行为特征的抽象，方法是类或对象最重要的组成部分。但从功能上来看，方法完全类似千传统结构化程序设计里的函数。值得指出的是，Java里的方法不能独立存在，所有的方法都必须定义在类里。方法在逻辑上要么属于类， 要么属千对象。

## 方法的所属性
不论是从定义方法的语法来看，还是从方法的功能来看，都不难发现方法和函数之间的相似性。实际上， 方法确实是由传统的函数发展而来的， 方法与传统的函数有着显著不同： 在结构化编程语言里，函数是一等公民，整个软件由一个个的函数组成；在面向对象编程语言里，类才是一等公民，整个系统由一个个的类组成。因此在Java语言里， 方法不能独立存在， 方法必须属于类或对象。

因此，如果需要定义方法，则只能在类体内定义，不能独立定义一个方法。一旦将一个方法定义在某个类的类体内，如果这个方法使用了static修饰， 则这个方法属于这个类，否则这个方法属于这个类的实例。

Java语言是静态的。一个类定义完成后，只要不再重新编译这个类文件，该类和该类的对象所拥有的方法是固定的， 永远都不会改变。

因为Java里的方法不能独立存在， 它必须属于一个类或一个对象， 因此方法也不能像函数那样被独立执行，执行方法时必须使用类或对象来作为调用者，即所有方法都必须使用“ 类.方法” 或“ 对象.方法” 的形式来调用。这里可能产生一个问题：同一个类里不同方法之间相互调用时，不就可以直接调用吗？这里需要指出：同一个类的一个方法调用另外一个方法时，如果被调方法是普通方法，则默认使用this作为调用者；如果被调方法是静态方法，则默认使用类作为调用者。也就是说，表面上看起来某些方法可以被独立执行， 但实际上还是使用this或者类来作为调用者。

永远不要把方法当成独立存在的实体，正如现实世界由类和对象组成，而方法只能作为类和对象的附属，Java语言里的方法也是一样。Java语言里方法的所属性主要体现在如下几个方面。
- 方法不能独立定义， 方法只能在类体里定义。
- 从逻辑意义上来看， 方法要么属于该类本身， 要么属于该类的一个对象。
- 永远不能独立执行方法， 执行方法必须使用类或对象作为调用者。

使用static修饰的方法属于这个类本身，使用static修饰的方法既可以使用类作为调用者来调用，也可以使用对象作为调用者来调用。但值得指出的是， 因为使用static修饰的方法还是属于这个类的，因此使用该类的任何对象来调用这个方法时将会得到相同的执行结果，这是由于底层依然是使用这些实例所属的类作为调用者。

没有static修饰的方法则属于该类的对象，不属于这个类本身。因此没有static修饰的方法只能使用对象作为调用者来调用，不能使用类作为调用者来调用。使用不同对象作为调用者来调用同一个普通方法，可能得到不同的结果。


## 参数传递机制
前面已经介绍了Java里的方法是不能独立存在的， 调用方法也必须使用类或对象作为主调者。如果声明方法时包含了形参声明， 则调用方法时必须给这些形参指定参数值， 调用方法时实际传给形参的参数值也被称为实参。

那么， Java的实参值是如何传入方法的呢？这是由Java方法的参数传递机制来控制的，Java里方法的参数传递方式只有一种：值传递。所谓值传递，就是将实际参数值的副本（复制品）传入方法内，**而参数本身不会受到任何影响**；

下面程序演示了基本类型参数传递的效果。
```
private static void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    System.out.println("swap方法中，a = " + a + ",b = " + b);
}

public static void main(String[] args) {
    int a = 6;
    int b = 9;
    swap(a, b);
    System.out.println("main方法中，a = " + a + ",b = " + b);
}
```
上面的程序输出的结果为：
```
swap方法中，a = 9,b = 6
main方法中，a = 6,b = 9
```
从上面运行结果来看，swap()方法里a和b的值是9、6, 交换结束后， 变量a和b的值依然是6、9。从这个运行结果可以看出， main()方法里的变量a和b, 并不是swap()方法里的a和b。正如前面讲的，swap()方法的a和b 只是mai顶）方法里变量a和b 的复制品。下面通过示意图来说明上面程序的执行过程。
```
    |       |           |       |           |       |
    |       |           |       |           |       |
    |       |           |       |           |-------|
    |       |           |       |      temp |   6   |
    |-------|           |-------|           |-------|
  b |   9   |-------> b |   9   |         b |   6   |
    |-------|           |-------|           |-------|
  a |   6   |-------> a |   6   |         a |   9   |
    |-------|           |-------|           |-------|
     main栈区            swap栈区          交换后swap栈区
```
在main()方法中调用swap()方法时， main()方法还未结束。因此， 系统分别为main()方法和swap()方法分配两块栈区， 用于保存main()方法和swap()方法的局部变量。main()方法中的a、b变量作为参数值传入swap()方法，实际上是在swap()方法栈区中重新产生了两个变量a、b, 并将main()方法栈区中a、b变量的值分别赋给swap()方法栈区中的a、b 参数（就是对swap()方法的a、b 形参进行了初始化）。此时， 系统存在两个a变量、两个b变量， 只是存在于不同的方法栈区中而已。

程序在swap()方法中交换a、b两个变量的值，实际上是将形参a赋值给temp，再将形参b赋值给形参a，最后将temp赋值给形参b；

对于引用类型的参数传递， 一样采用的是值传递方式。但某些现象可能对引用类型的参数传递会产生一些误会。下面程序示范了引用类型的参数传递的效果。
```
public class Hello {
    public static class DataWrap {
        int a;
        int b;
    }

    private static void swap(DataWrap dataWrap) {
        int temp = dataWrap.a;
        dataWrap.a = dataWrap.b;
        dataWrap.b = temp;
        System.out.println("swap方法中，a = " + dataWrap.a + ",b = " + dataWrap.b);
    }

    public static void main(String[] args) {
        DataWrap dataWrap = new DataWrap();
        dataWrap.a = 6;
        dataWrap.b = 9;
        swap(dataWrap);
        System.out.println("main方法中，a = " + dataWrap.a + ",b = " + dataWrap.b);
    }
}
```
上面的程序运行后结果如下：
```
swap方法中，a = 9,b = 6
main方法中，a = 9,b = 6
```
从上面运行结果来看，在swap()方法里，a、b两个成员变量的值被交换成功。不仅如此， 当swap()方法执行结束后，main()方法里a、b两个成员变量的值也被交换了。这很容易造成一种错觉：调用swap()方法时，传入swap()方法的就是dw 对象本身， 而不是它的复制品。但这只是一种错觉， 下面还是结合示意图来说明程序的执行过程。
```
        |       |           |       |
        |       |           |       | 
        |       |           |       | 
        |-------|  dataWrap |-------|
dataWrap| 10000 |---------->| 10000 |
        |-------|           |-------|
         main栈区            wrap栈区       

       DataWrap对象
        |-------|           |-------|
   10000|   6   | a    10000|   9   | a
        |-------|           |-------|
   10001|   9   | b    10001|   6   | b
        |-------|           |-------|
        |       |           |       |
       堆内存交换前         堆内存交换后
```
这种参数传递方式是不折不扣的值传递方式，系统一样复制了dataWrap的副本传入swap()方法， 但关键在于dataWrap只是一个引用变量，所以系统复制了dataWrap变量，但并未复制DataWrap对象。

## 可变形参
从JDK1.5之后，Java允许定义形参个数可变的参数， 从而允许为方法指定数量不确定的形参。如果在定义方法时， 在最后一个形参的类型后增加三点（...）， 则表明该形参可以接受多个参数值， 多个参数值被当成数组传入。也就是说，下面两个方法签名的效果完全一样。
```
public static void test(int a,String... books)
public static void test(int a,String[] ks)
```
这两种形式都包含了一个名为books的形参，在两个方法的方法体内都可以把books 当成数组处理。但区别是调用两个方法时存在差别，对于以可变形参的形式定义的方法，调用方法时更加简洁，如下面代码所示。
```
test(1,"aaa","bbbb","ccc");
test(2,new String[]{"aaa","bbbb","ccc"});
```
对比两种调用test()方法的代码，明显第一种形式更加简洁。实际上，即使是采用形参个数可变的形式来定义方法，调用该方法时也一样可以为个数可变的形参传入一个数组。

最后还要指出的是，数组形式的形参可以处于形参列表的任意位置，但个数可变的形参只能处于形参列表的最后。也就是说，一个方法中最多只能有一个个数可变的形参。

## 递归方法
一个方法体内调用他自身，被称为方法递归。方法递归包含一种隐式的循环，他会重复执行某段代码，但这种重复执行无需循环控件；

例如有如下数学题。已知有一个数列： f(0)=1 , f(1)=4, f(n + 2) =2*f(n+1)+f(n), 其中n是大于0的整数，求f(10)的值。
```
private static int fn(int n){
    if(n == 0){
        return 1;
    }else if(n == 1){
        return 4;
    }else{
        return 2*fn(n-1) + fn(n-2);
    }
}
```
在上面的fn方法体中，再次调用了fn方法，这就是方法递归。对于fn(10), 即等于`2*fn(9)+fn(8)`, 其中fn(9)又等于`2*fn(8)+fn(7)`……依此类推，最终会计算到fn(2)等于`2*fn(1)+fn(0)`,即fn(2)是可计算的，然后一路反算回去，就可以最终得到fn(10)的值。

仔细看上面递归的过程，当一个方法不断地调用它本身时，必须在某个时刻方法的返回值是确定的，即不再调用它本身，否则这种递归就变成了无穷递归，类似于死循环。因此定义递归方法时有一条最重要的规定：**递归一定要向已知方向递归。**

递归是非常有用的。例如希望遍历某个路径下的所有文件， 但这个路径下文件夹的深度是未知的，那么就可以使用递归来实现这个需求。系统可定义一个方法，该方法接受一个文件路径作为参数，该方法可遍历当前路径下的所有文件和文件路径——该方法中再次调用该方法本身来处理该路径下的所有文件路径。

总之，只要一个方法的方法体实现中再次调用了方法本身，就是递归方法。递归一定要向已知方向递归。

## 方法重载
Java允许同一个类里定义多个同名方法，只要形参列表不同就行。如果同一个类中包含了两个或两个以上方法的方法名相同， 但形参列表不同， 则被称为方法重载。

从上面介绍可以看出，在Java程序中确定一个方法需要三个要素。
- 调用者， 也就是方法的所属者， 既可以是类， 也可以是对象。
- 方法名， 方法的标识。
- 形参列表，当调用方法时， 系统将会根据传入的实参列表匹配。

方法重载的要求就是两同一不同： 同一个类中方法名相同， 参数列表不同。至于方法的其他部分，如方法返回值类型、修饰符等， 与方法重载没有任何关系。

不仅如此，如果被重载的方法里包含了个数可变的形参，则需要注意。看下面程序里定义的两个重载的方法。
```
public class Hello {
    private void test(String params){
        System.out.println(params);
    }

    private void test(String... params){
        System.out.println(Arrays.toString(params));
    }

    public static void main(String[] args) {
        Hello hello = new Hello();
        //调用的可变参数方法
        hello.test(); //[]
        hello.test("params1","params2"); //[params1, params2]
        //调用的单参数方法
        hello.test("params"); //params
    }
}
```
通过这个程序可以看出， 如果同一个类中定义了test(String... books)方法，同时还定义了一个test(String)方法，则test(String... books)方法的books 不可能通过直接传入一个字符串参数来调用，如果只传入一个参数，系统会执行重载的test(String)方法。如果需要调用test(String... books)方法，又只想传入一个字符串参数，则可采用传入字符串数组的形式；

大部分时候并不推荐重载形参个数可变的方法，因为这样做确实没有太大的意义，而且容易降低程序的可读性。