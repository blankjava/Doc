## Lambda语法
在高阶函数中，函数可以作为参数或返回值，那么就会有函数类型的值，而Lambda表达式就是函数类型值的一种，即“函数字面值”，也就是说Lambda表达式是函数类型的一个实例；

Lambda表达式的完整语法形式如下：
```
val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y }
```
Lambda表达式总是在花括号中，完整语法中的参数声明放在花括号内，并有可选的类型标注，函数体跟在一个`->`符号之后。如果推断出的该Lambda的返回类型不是Unit，那么该Lambda主体中的最后一个表达式会视为返回值。

## 传递末尾的Lambda
在 Kotlin 中有一个约定：如果函数的最后一个参数是函数，那么作为相应参数传入的 lambda 表达式可以放在圆括号之外：
```
val product = items.fold(1) { acc, e -> acc * e }
```
这种语法也称为拖尾 lambda 表达式。

如果该 lambda 表达式是调用时唯一的参数，那么圆括号可以完全省略：
```
run { println('...') }
```

## 单参数的隐式名称
如果Lambda表达式中只有一个参数，可以不用声明唯一的参数并忽略 ->。该参数会隐式声明为it：
```
ints.filter { it > 0 } // 这个字面值是“(it: Int) -> Boolean”类型的
```

如果Lambda表达式没有参数，同样可以省略->符号；

## 未使用的变量
如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称：
```
map.forEach { _, value -> println('$value!') }
```

## 带有接收者的函数字面值
带有接收者的函数类型，例如 A.(B) -> C，可以用带有接收者的函数字面值初始化。

在这样的函数字面值内部，接收者对象成为隐式的this，以便访问接收者对象的成员时无需任何额外的限定符，亦可使用 this 表达式 访问接收者对象。这种行为与扩展函数类似，扩展函数也允许在函数体内部访问接收者对象的成员。
```
val sum: Int.(Int) -> Int = { other -> plus(other) }
```
上面程序中，调用了接收者对象的plus函数；


